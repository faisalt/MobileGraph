<!--
* Shows pixels to control the shapeclip heights, e.g. by mapping values from a dataset
*
* @author Faisal T
*
-->
<!doctype html>
<head>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
	<script type="text/javascript" src="JavaScript/ShapeClipAPI.js"></script>
	<script src="http://localhost:3000/socket.io/socket.io.js"></script>
	<link rel=StyleSheet href="Style/style.css" type="text/css">
</head>
<body>
	<div class="horizontal_axis">
	</div>
	<div class="vertical_axis">
	</div>
	<div class="PXGrid"></div>
	<div class="buttons">
		<input type="image" id="up" onclick="return false" src="images/up.png"></input>
		<input type="image" id="down" onclick="return false" src="images/down.png"></input>
		<input type="image" id="previous" onclick="return false" src="images/left.png"></input>
		<input type="image" id="next" onclick="return false" src="images/right.png"></input>
		<input type="image" onclick="location.reload();" id="refresh" src="images/reload.png"></input>
	</div>
</body>
</html>
<script type="text/javascript">

var conn="";
var h_pageCounter=0;
var v_pageCounter=0;

$(document).ready(function() {
	$.getScript('config.js').done(function(script, textStatus){
		//$.getScript('http://'+host+':'+port+'/socket.io/socket.io.js').done(function(script, textStatus){ 
		//conn = io.connect('ws://'+host+':'+port+'/');
		conn = io.connect('ws://localhost:'+port+'/');
			createGrid();
			generateVerticalLabels();
			generateHorizontalLabels();
		});
	//});
});

/*
* This creates the pixel grid that controls the ShapeClips
*/
function createGrid() {
	var x=1;
	var y=1;
	var count=1;
	var pads = [];
	// Correct ppi value.
	var agent = navigator.userAgent.toLowerCase();
	if 		(agent.indexOf("windows") 	!= -1) 	{ }
	if 		(agent.indexOf("nexus 5") 	!= -1) 	{ __ppi(150); }
	else if (agent.indexOf("ipad") 		!= -1) 	{ __ppi(160); }
	else if (agent.indexOf("nexus 10") 		!= -1) 	{ __ppi(180); }
	console.log("User Agent: " + agent);
	
	// The size of the shape-clip pad in mm.
	var SC_SIZE = __px(20);
	// The starting position of the grid
	var X = 19;	var Y = 25;
	
	for (var x = 0; x < 5; ++x) {
		for (var y = 0; y < 6; ++y) {
			var pX = X + (x * 25); // 29 -- horizontal spacing between pixels
			var pY = Y + (y * 26); // 33 -- vertical spacing between pixels
			
			var pad = null;
			pad = new ShapeClip({x: __px(pX), y: __px(pY), width: SC_SIZE, height: SC_SIZE});
			
			//pad._id = "" + x + "x" + y;
			pad._id="pixel_"+count;
			count++;
			pad.outline(true);
			pad.rotate(180);
			pads.push(pad);
			
		}
	}
	/*
	* -------------------------------------------------	
	* ----------- WebSocket handlers ------------------
	* -------------------------------------------------
	*/
	conn.on('connect', function(data) {
		console.log("Chart Client Connection Established!");
	});
	conn.on("serverMsg", function(data) {
		console.log("Broadcasted server message:");	
		
		//Set unique colours for each row so they are distinguishable
		var count=0;
		var colorArray = getRandomColor(v_max);
		for(var i=0; i<h_max; i++) {
			for(var j=0; j<v_max; j++) {
				pads[count++].colour(colorArray[j].r, colorArray[j].g, colorArray[j].b);
			}
		}
		//Start the pixel pads
		for (var i=0; i<pads.length; ++i) { pads[i].pulse(); }
		
		//Parse message from server (i.e. JSON array of values)
		var obj = JSON.parse(data);
		var obj_data = obj['Data'][1].RainfallVals;
		var obj_headings = obj['Data'][0].Headings;
		
		var pagingLimit=obj_data.length-h_max; //data limit across minus how many there are on the grid
		var v_pagingLimit=obj_headings.length-v_max; //data limit up-down minus how may there are on the grid
		
		/*
		* ___TO FIX: repetitive calls to mapValues() is inefficient, should think of a better way___
		*/
		mapValues(pads, obj_data, h_pageCounter, v_pageCounter, h_max, v_max, obj_headings);
		
		/* 
		* Button handlers to navigate through graph data - horizontally and vertically 
		* as not everything will fit in a 6x5 grid
		*/
		$('input#previous').click(function() {
			if(h_pageCounter>0) h_pageCounter--;
			mapValues(pads, obj_data, h_pageCounter, v_pageCounter, h_max, v_max, obj_headings);
		});
		$('input#next').click(function() {
			if(h_pageCounter<pagingLimit) h_pageCounter++;
			mapValues(pads, obj_data, h_pageCounter, v_pageCounter, h_max, v_max, obj_headings);
		});
		$('input#up').click(function() {
			if(v_pageCounter>0) v_pageCounter--;
			mapValues(pads, obj_data, h_pageCounter, v_pageCounter, h_max, v_max, obj_headings);
		});
		$('input#down').click(function() {
			if(v_pageCounter<v_pagingLimit) v_pageCounter++;
			mapValues(pads, obj_data, h_pageCounter, v_pageCounter, h_max, v_max, obj_headings);
		});
	});	
	
	//Test message from server (for handshake purposes)
	conn.on("serverTestMsg", function(data) {
		alert("Controller has sent a message: "+data);
	});
	
	//The ShapeClips need to know the limits of black/white
	conn.on("calibrationRequest", function(data) {
		for (var i=0; i<pads.length; ++i) { pads[i].stopPulse(); }
		if(data == "white") {
			for (var i=0; i<pads.length; ++i) { pads[i]._ldr1(1);pads[i]._ldr2(1); }
		}
		else if(data == "black") {
			for (var i=0; i<pads.length; ++i) { pads[i]._ldr1(0);pads[i]._ldr2(0); }
		}
	});
}

/*
* Maps the values sent from the controller (i.e. height values, etc.) to the bar chart interface
*
* @param pads
* @param values
* @param h_pagination
* @param v_pagination
* @param h_limit
* @param v_limit
*/
function mapValues(pads, values, h_pagination, v_pagination, h_limit, v_limit, v_labels) {
	var count=0;
	var x_axis = new Array();
	var y_axis = new Array();
	for(var i=h_pagination; i<h_pagination+h_limit; i++) {
		for(var j=v_pagination+1; j<(v_pagination+1)+v_limit; j++) {
			pads[count++].height(values[i][j]*0.01);
		}
	}
	for(var i=h_pagination; i<h_pagination+h_limit; i++) { x_axis.push(values[i][0]); } //the first value in the json array is the horizontal axis labels
	for(var j=v_pagination+1; j<(v_pagination+1)+v_limit; j++) { y_axis.push(v_labels[j]); } //cycle through the vertical labels based on navigation value
	generateVerticalLabels(y_axis);
	generateHorizontalLabels(x_axis);
}

/*
* Generate labels across the horizontal axis
*
* @data the label data
*/
function generateHorizontalLabels(data) {
	$('div.horizontal_axis').empty();
	for(var i=0; i<h_max; i++) { 
		if(data == null) $('div.horizontal_axis').append("<label id='val"+i+"'>Val_"+i+"</label>"); 
		else {
			$('div.horizontal_axis').append("<label id='val"+i+"'>"+data[i]+"</label>");
		}
	}
}

/*
* Generate labels across the vertical axis
*
* @data the label data
*/
function generateVerticalLabels(data) {
	$('div.vertical_axis').empty();
	for(var i=0; i<v_max; i++) { 
		if(data == null) $('div.vertical_axis').append("<label id='val1'>Val_"+i+"</label>"); 
		else {
			$('div.vertical_axis').append("<label id='val1'>"+data[i]+"</label>"); 
		}
	}
}

/*
* Generate a random and unique RGB colour array
*
* @param rownum the number of rows that need random colours (each row is a different colour)
*/
function getRandomColor(rownum) {
	var colorarray = new Array();
	var count=0;
	var tempColor="";
	while(count < rownum) {
		for(var i=0; i<rownum; i++) {
			var letters = '0123456789ABCDEF'.split('');
			var color = '#';
			for (var i = 0; i < 6; i++ ) {
				color += letters[Math.floor(Math.random() * 16)];
			}
			color = hexToRgb(color);
			if(color != tempColor) {
				colorarray.push(color);
				count++;
			}
			tempColor = color;
		}
	}
    return colorarray;
}

/*
* Convert a hexadecmial value to an RGB array
*
* @param hex the hexadecmial value
*/
function hexToRgb(hex) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}
</script>